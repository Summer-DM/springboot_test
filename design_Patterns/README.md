##装饰者模式
###1、适用环境
    （1）在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。
    （2）处理那些可以撤消的职责。
    （3）当不能采用生成子类的方法进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的 子类，使得子类数目呈爆炸性增长。另一种情况可能是因为类定义被隐藏，或类定义不能用于生成子类。
###2、特点：
    1、继承属于扩展形式之一，但不见得是达到弹性设计的最佳方案。
    2、在我们的设计中，应该允许行为可以被扩展，而不须修改现有的代码。
    3、组合和委托可用于在运行时动态地加上新的行为。
    4、除了继承，装饰者模式也可以让我们扩展行为。
    5、装饰者模式意味着一群装饰者类， 这些类用来包装具体组件。
    6、装饰者类反映出被装饰的组件类型（实际上，他们具有相同的类型，都经过接口或继承实现）。
    7、装饰者可以在被装饰者的行为前面与/或后面加上自己的行为，甚至将被装饰者的行为整个取代掉，而达到特定的目的。
    8、你可以有无数个装饰者包装一个组件。
    9、 装饰者一般对组建的客户是透明的，除非客户程序依赖于组件的具体类型。
##单例模式
###1、特点
    （1）、单例类只能有一个实例。
    （2）、单例类必须自己创建自己的唯一实例。
    （3）、单例类必须给所有其他对象提供这一实例。
###2、场景
    单例模式确保某个类只有一个实例，而且自行实例化并向整个系统提供这个实例。
    在计算机系统中，线程池、缓存、日志对象、对话框、打印机、显卡的驱动程序对象常被设计成单例。
    这些应用都或多或少具有资源管理器的功能。每台计算机可以有若干个打印机，但只能有一个Printer Spooler，以避免两个打印作业同时输出到打印机中。
    每台计算机可以有若干通信端口，系统应当集中管理这些通信端口，以避免一个通信端口同时被两个请求同时调用。总之，选择单例模式就是为了避免不一致状态，避免政出多头。
###3、模式
    （1）汉式单例
    （2）饿汉式单例
    （3）登记式单例
###4、说明---饿汉式和懒汉式区别
    从名字上来说，饿汉和懒汉，
    饿汉就是类一旦加载，就把单例初始化完成，保证getInstance的时候，单例是已经存在的了，
    而懒汉比较懒，只有当调用getInstance的时候，才回去初始化这个单例。
####另外从以下两点再区分以下这两种方式：
    1、线程安全：
        饿汉式天生就是线程安全的，可以直接用于多线程而不会出现问题，
        懒汉式本身是非线程安全的，为了实现线程安全有几种写法，分别是上面的1、2、3，这三种实现在资源加载和性能方面有些区别。
    2、资源加载和性能：
        饿汉式在类创建的同时就实例化一个静态对象出来，不管之后会不会使用这个单例，都会占据一定的内存，但是相应的，在第一次调用时速度也会更快，因为其资源已经初始化完成，
        而懒汉式顾名思义，会延迟加载，在第一次使用该单例的时候才会实例化对象出来，第一次调用时要做初始化，如果要做的工作比较多，性能上会有些延迟，之后就和饿汉式一样了。
    至于1、2、3这三种实现又有些区别，
        第1种，在方法调用上加了同步，虽然线程安全了，但是每次都要同步，会影响性能，毕竟99%的情况下是不需要同步的，
        第2种，在getInstance中做了两次null检查，确保了只有第一次调用单例的时候才会做同步，这样也是线程安全的，同时避免了每次都同步的性能损耗
        第3种，利用了classloader的机制来保证初始化instance时只有一个线程，所以也是线程安全的，同时没有性能损耗，所以一般我倾向于使用这一种。
    什么是线程安全？
        如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。
        或者说：一个类或者程序所提供的接口对于线程来说是原子操作，或者多个线程之间的切换不会导致该接口的执行结果存在二义性,也就是说我们不用考虑同步的问题，那就是线程安全的。
##工厂模式
###场景
    提供一个用于创建对象的接口(工厂接口)，让其实现类(工厂实现类)决定实例化哪一个类(产品类)，并且由该实现类创建对应类的实例
###特点
####优点
    1 它是一个具体的类，非接口 抽象类。有一个重要的create()方法，利用if或者 switch创建产品并返回。
    2 create()方法通常是静态的，所以也称之为静态工厂。
####缺点
    1 扩展性差（我想增加一种面条，除了新增一个面条产品类，还需要修改工厂类方法）
    2 不同的产品需要不同额外参数的时候 不支持。
